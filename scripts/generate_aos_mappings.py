 codex/standardize-linting,-formatting,-and-dependencies
=======
import argparse
 main
import json
import os
import sys

LOG_PATH = "AOS-CHECKLIST.log"
MAPPINGS_JSON = "mappings.json"


def log(msg):
    # For CI validation we print messages but avoid modifying the checklist file
    print(msg)


def load_mappings(path):
 codex/standardize-linting,-formatting,-and-dependencies
    with open(path) as f:
        data = json.load(f)
    cats = {}
    for name, info in data.get("categories", {}).items():
        if isinstance(info, dict):
            cid = int(info.get("id", 0))
            macro = info.get("macro", "CAT_" + name.upper().replace(" ", "_"))
        else:
            cid = int(info)
            macro = "CAT_" + name.upper().replace(" ", "_")
        cats[name] = (macro, cid)
    cmds = []
    for entry in data.get("commands", []):
        cmds.append((entry["name"], entry["binary"], entry.get("category")))
=======
    try:
        with open(path) as f:
            data = json.load(f)
    except FileNotFoundError:
        raise SystemExit(f"Error: {path} not found")
    except json.JSONDecodeError as e:
        raise SystemExit(f"Error parsing {path}: {e}")
    cats = {}
    for name, info in data.get('categories', {}).items():
        if isinstance(info, dict):
            cid = int(info.get('id', 0))
            macro = info.get('macro', 'CAT_' + name.upper().replace(' ', '_'))
        else:
            cid = int(info)
            macro = 'CAT_' + name.upper().replace(' ', '_')
        cats[name] = (macro, cid)
    cmds = []
    for entry in data.get('commands', []):
        cmds.append((entry['name'], entry['binary'], entry.get('category')))
 main
    return cats, cmds


def handler_name(cmd):
 codex/standardize-linting,-formatting,-and-dependencies
    return "cmd_" + cmd.lower().replace(" ", "_") + "_wrapper"


def generate_files(cmds, cats):
    with open("command_map.c", "w") as f:
        f.write("// Auto-generated by generate_aos_mappings.py\n")
        f.write('#include "interpreter.h"\n\n')
        f.write("void init_command_map() {\n")
        for name, _, _ in cmds:
            f.write(f'  add_command("{name}", {handler_name(name)});\n')
        f.write("}\n")

    with open("commands.c", "w") as f:
        f.write("// Auto-generated: CommandDictionary array\n")
        f.write('#include "command_interpreter.h"\n\n')
        f.write("CommandDictionary commands[] = {\n")
        for name, binary, cat_name in cmds:
            cat_macro = "0"
            if cat_name and cat_name in cats:
                cat_macro = cats[cat_name][0]
            f.write(
                f'  {{ "{name}", "{binary}", {handler_name(name)}, {cat_macro} }},\n'
            )
        f.write("  { NULL, NULL, NULL, 0 }\n};\n")

    with open(os.path.join("include", "category_defs.h"), "w") as f:
        f.write("// Auto-generated category IDs\n")
        f.write("#ifndef CATEGORY_DEFS_H\n#define CATEGORY_DEFS_H\n\n")
        for name, (macro, cid) in cats.items():
            f.write(f"#define {macro} 0x{cid:02X}\n")
        f.write("\n#endif\n")
=======
    return 'cmd_' + cmd.lower().replace(' ', '_') + '_wrapper'


def generate_files(cmds, cats, outdir):
    os.makedirs(outdir, exist_ok=True)
    with open(os.path.join(outdir, "command_map.c"), "w") as f:
        f.write('// Auto-generated by generate_aos_mappings.py\n')
        f.write('#include "interpreter.h"\n\n')
        f.write('void init_command_map() {\n')
        for name, _, _ in cmds:
            f.write(f'  add_command("{name}", {handler_name(name)});\n')
        f.write('}\n')

    with open(os.path.join(outdir, "commands.c"), "w") as f:
        f.write('// Auto-generated: CommandDictionary array\n')
        f.write('#include "command_interpreter.h"\n\n')
        f.write('CommandDictionary commands[] = {\n')
        for name, binary, cat_name in cmds:
            cat_macro = '0'
            if cat_name and cat_name in cats:
                cat_macro = cats[cat_name][0]
            f.write(f'  {{ "{name}", "{binary}", {handler_name(name)}, {cat_macro} }},\n')
        f.write('  { NULL, NULL, NULL, 0 }\n};\n')

    with open(os.path.join(outdir, "category_defs.h"), "w") as f:
        f.write('// Auto-generated category IDs\n')
        f.write('#ifndef CATEGORY_DEFS_H\n#define CATEGORY_DEFS_H\n\n')
        for name, (macro, cid) in cats.items():
            f.write(f'#define {macro} 0x{cid:02X}\n')
        f.write('\n#endif\n')
 main


def validate(cmds, cats):
    for name, binary, cat in cmds:
        if cat and cat not in cats:
 codex/standardize-linting,-formatting,-and-dependencies
            log(f"Error: unknown category {cat} for {name}")
            return False
        if len(binary) != 64:
            log(f"Error: binary length for {name}")
            return False
    log("Mappings validated")
    return True


def main():
    if "--validate" in sys.argv:
        cats, cmds = load_mappings(MAPPINGS_JSON)
=======
            log(f'Error: unknown category {cat} for {name}')
            return False
        if len(binary) != 64:
            log(f'Error: binary length for {name}')
            return False
    log('Mappings validated')
    return True


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate C source files from mappings.json"
    )
    parser.add_argument(
        "--validate",
        action="store_true",
        help="only validate mappings.json and exit",
    )
    parser.add_argument(
        "--outdir",
        default="gen",
        help="directory to write generated files",
    )

    args = parser.parse_args()

    cats, cmds = load_mappings(MAPPINGS_JSON)

    if args.validate:
 main
        ok = validate(cmds, cats)
        sys.exit(0 if ok else 1)

    open(LOG_PATH, "w").close()
 codex/standardize-linting,-formatting,-and-dependencies
    cats, cmds = load_mappings(MAPPINGS_JSON)
    if not validate(cmds, cats):
        sys.exit(1)
    generate_files(cmds, cats)
    print("Generated command_map.c, commands.c, and category_defs.h")


if __name__ == "__main__":
=======
    if not validate(cmds, cats):
        sys.exit(1)

    try:
        generate_files(cmds, cats, args.outdir)
    except OSError as e:
        log(f"Error writing files: {e}")
        sys.exit(1)
    print(f"Generated command_map.c, commands.c, and category_defs.h in {args.outdir}")


if __name__ == '__main__':
 main
    main()
