import os
import re
import csv
import sys

# Files
NATIVELANG = 'nativelang.txt'
NEWLANGBIN = 'newlangxbinary.txt'
UPDATEBINARY = 'updatebinary_laang.txt'

# Parse nativelang.txt

def parse_nativelang(path):
    commands = []
    if not os.path.exists(path):
        return commands
    with open(path, 'r') as f:
        for line in f:
            m = re.search(r'add_command\("([^"]+)",\s*([A-Za-z0-9_]+)\)', line)
            if m:
                cmd = m.group(1)
                handler = m.group(2)
                commands.append((cmd, handler))
    return commands

# Parse newlangxbinary.txt

def parse_newlangbin(path):
    entries = []
    if not os.path.exists(path):
        return entries
    with open(path, 'r') as f:
        for line in f:
            m = re.search(r'\{\s*"([^"]+)",\s*"([0-9A-Fa-f]+)",\s*([A-Za-z0-9_]+)\s*\}', line)
            if m:
                cmd = m.group(1)
                binary = m.group(2)
                handler = m.group(3)
                entries.append((cmd, binary, handler))
    return entries

# Parse updatebinary laang.txt

def parse_categories(path):
    categories = {}
    if not os.path.exists(path):
        return categories
    with open(path, 'r', newline='') as f:
        reader = csv.reader(f, delimiter=',')
        for row in reader:
            if not row or row[0].startswith('#'):
                continue
            if len(row) < 3:
                # try tab separated
                row = row[0].split('\t')
                if len(row) < 3:
                    continue
            _, name, hex_id = row[0].strip(), row[1].strip(), row[2].strip()
            if hex_id.lower().startswith('0x'):
                cat_id = int(hex_id, 16)
            else:
                cat_id = int(hex_id)
            categories[name] = cat_id
    return categories


def get_category(cmd, categories):
    upper_cmd = cmd.upper()
    for name in categories:
        up = name.upper()
        if upper_cmd.startswith(up + '_') or upper_cmd.startswith(up + '.') or upper_cmd == up:
            return name
    return None


def generate_files(cmd_list, bin_list, categories):
    # command_map.c
    with open('command_map.c', 'w') as f:
        f.write('// Auto-generated by generate_aos_mappings.py\n')
        f.write('#include "interpreter.h"\n\n')
        f.write('void init_command_map() {\n')
        for cmd, handler in cmd_list:
            f.write(f'  add_command("{cmd}", {handler});\n')
        f.write('}\n')

    # commands.c
    with open('commands.c', 'w') as f:
        f.write('// Auto-generated: CommandDictionary array\n')
        f.write('#include "command_interpreter.h"\n\n')
        f.write('CommandDictionary commands[] = {\n')
        for cmd, binary, handler in bin_list:
            f.write(f'  {{ "{cmd}", "{binary}", {handler} }},\n')
        f.write('  { NULL, NULL, NULL }\n};\n')

    # category_defs.h
    with open('category_defs.h', 'w') as f:
        f.write('// Auto-generated category IDs\n')
        f.write('#ifndef CATEGORY_DEFS_H\n#define CATEGORY_DEFS_H\n\n')
        for name, cid in categories.items():
            macro = name.upper().replace(' ', '_')
            f.write(f'#define CAT_{macro}  0x{cid:X}\n')
        f.write('\n#endif\n')


def main():
    cmds = parse_nativelang(NATIVELANG)
    bins = parse_newlangbin(NEWLANGBIN)
    cats = parse_categories(UPDATEBINARY)

    # Validation
    for cmd, binary, _ in bins:
        cat = get_category(cmd, cats)
        if cat is None:
            print(f'Error: no category for command {cmd}')
            sys.exit(1)
        cat_id = cats[cat]
        if len(binary) == 0:
            print(f'Error: empty binary for {cmd}')
            sys.exit(1)
        first_digit = int(binary[0], 16)
        if first_digit != cat_id:
            print(f'Error: category ID mismatch for {cmd}: expected {cat_id:X}, got {binary[0]}')
            sys.exit(1)

    generate_files(cmds, bins, cats)
    print('âœ… Generated command_map.c, commands.c, and category_defs.h')

if __name__ == '__main__':
    main()
