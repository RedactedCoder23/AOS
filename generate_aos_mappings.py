import os
import re
import sys

LOG_PATH = 'AOS-CHECKLIST.log'

def log(msg):
    with open(LOG_PATH, 'a') as lf:
        lf.write(msg + '\n')
    print(msg)

# Files
NATIVELANG = 'nativelang.txt'
NEWLANGBIN = 'newlangxbinary.txt'
UPDATEBINARY = 'updatebinary_laang.txt'

# Parse nativelang.txt

def parse_nativelang(path):
    commands = []
    if not os.path.exists(path):
        return commands
    with open(path, 'r') as f:
        for line in f:
            m = re.search(r'add_command\("([^"]+)",\s*([A-Za-z0-9_]+)\)', line)
            if m:
                cmd = m.group(1)
                commands.append(cmd)
    return commands

# Parse newlangxbinary.txt

def parse_newlangbin(path):
    entries = {}
    if not os.path.exists(path):
        return entries
    with open(path, 'r') as f:
        for line in f:
            m = re.search(r'\{\s*"([^"]+)",\s*"([0-9A-Fa-f]+)",\s*[A-Za-z0-9_]+\s*\}', line)
            if m:
                cmd = m.group(1)
                binary = m.group(2)
                entries[cmd] = binary
    return entries

# Parse updatebinary_laang.txt for category definitions
def parse_categories(path):
    categories = {}
    if not os.path.exists(path):
        log(f"Error: missing {path}")
        return categories
    seen = {}
    with open(path) as f:
        next(f, None)  # skip header
        for line in f:
            parts = [c.strip() for c in line.split('\t')]
            if len(parts) < 3:
                continue
            _, name, hexid = parts
            sanitized = re.sub(r'[^A-Za-z0-9]', '_', name.upper())
            sanitized = re.sub(r'_+', '_', sanitized)
            macro = 'CAT_' + sanitized
            if sanitized in seen:
                log(f"Warning: duplicate category macro {macro} for '{name}' and '{seen[sanitized]}'")
                continue
            seen[sanitized] = name
            categories[name] = (macro, int(hexid, 16))
    return categories


def get_category(cmd, categories):
    upper_cmd = cmd.upper()
    for name in categories:
        up = name.upper()
        if upper_cmd.startswith(up + '_') or upper_cmd.startswith(up + '.') or upper_cmd == up:
            return name
    # default to Basic System Commands if not matched
    if 'Basic System Commands' in categories:
        return 'Basic System Commands'
    return None


def handler_name(cmd):
    return 'cmd_' + cmd.lower().replace(' ', '_') + '_wrapper'


def handler_exists(name):
    for root, _, files in os.walk('.'):  # search source tree
        for fn in files:
            if fn.endswith('.c'):
                try:
                    with open(os.path.join(root, fn)) as f:
                        if re.search(r'\b' + re.escape(name) + r'\b', f.read()):
                            return True
                except Exception:
                    pass
    return False


def generate_files(cmd_list, bin_list, categories):
    # command_map.c
    with open('command_map.c', 'w') as f:
        f.write('// Auto-generated by generate_aos_mappings.py\n')
        f.write('#include "interpreter.h"\n\n')
        f.write('void init_command_map() {\n')
        for cmd in cmd_list:
            f.write(f'  add_command("{cmd}", {handler_name(cmd)});\n')
        f.write('}\n')

    # commands.c
    with open('commands.c', 'w') as f:
        f.write('// Auto-generated: CommandDictionary array\n')
        f.write('#include "command_interpreter.h"\n\n')
        f.write('CommandDictionary commands[] = {\n')
        for cmd, binary, _handler in bin_list:
            cat_name = get_category(cmd, categories)
            cat_macro = categories[cat_name][0] if cat_name else '0'
            f.write(f'  {{ "{cmd}", "{binary}", {handler_name(cmd)}, {cat_macro} }},\n')
        f.write('  { NULL, NULL, NULL, 0 }\n};\n')

    # category_defs.h
    with open(os.path.join('include', 'category_defs.h'), 'w') as f:
        f.write('// Auto-generated category IDs\n')
        f.write('#ifndef CATEGORY_DEFS_H\n#define CATEGORY_DEFS_H\n\n')
        for name, (macro, cid) in categories.items():
            f.write(f'#define {macro} 0x{cid:02X}\n')
        f.write('\n#endif\n')


def main():
    # reset checklist log
    open(LOG_PATH, 'w').close()

    cmds = parse_nativelang(NATIVELANG)
    bins_all = parse_newlangbin(NEWLANGBIN)
    cats = parse_categories(UPDATEBINARY)

    bins = []
    for cmd in cmds:
        binary = bins_all.get(cmd)
        if not binary:
            # default binary starts with category id
            cat = get_category(cmd, cats)
            cat_id = cats[cat][1] if cat else 0
            binary = f"{cat_id:01X}" + "0" * 63
        bins.append((cmd, binary, None))

    # Validation
    for cmd, binary, _ in bins:
        cat = get_category(cmd, cats)
        if cat is None:
            log(f'Warning: no category for command {cmd}')
            continue
        cat_id = cats[cat][1]
        if len(binary) == 0:
            log(f'Error: empty binary for {cmd}')
            sys.exit(1)
        first_digit = int(binary[0], 16)
        if first_digit != cat_id:
            log(f'Warning: category ID mismatch for {cmd}: expected {cat_id:X}, got {binary[0]}')

        if not handler_exists(handler_name(cmd)):
            log(f'Warning: missing handler stub for {cmd} ({handler_name(cmd)})')

    generate_files(cmds, bins, cats)
    print('Generated command_map.c, commands.c, and category_defs.h')

if __name__ == '__main__':
    main()
